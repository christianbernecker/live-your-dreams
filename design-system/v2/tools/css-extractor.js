#!/usr/bin/env node

/**
 * CSS-Extraktor fÃ¼r LYD Design System V2
 * Analysiert alle Komponenten und extrahiert gemeinsame CSS-Regeln
 * Ziel: Reduzierung von 1189 Zeilen auf ~100 Zeilen pro Komponente
 */

import fs from 'fs';
import path from 'path';
import { execSync } from 'child_process';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

class CSSExtractor {
    constructor() {
        this.componentsDir = path.join(__dirname, '../components');
        this.sharedDir = path.join(__dirname, '../shared');
        this.commonRules = new Map();
        this.componentSpecific = new Map();
    }

    async extractAllCSS() {
        console.log('ğŸ” Analysiere CSS-Redundanz in allen Komponenten...');
        
        const components = fs.readdirSync(this.componentsDir)
            .filter(dir => fs.existsSync(path.join(this.componentsDir, dir, 'index.html')));

        console.log(`ğŸ“ Gefundene Komponenten: ${components.join(', ')}`);

        // Schritt 1: CSS aus allen Komponenten extrahieren
        for (const component of components) {
            await this.extractComponentCSS(component);
        }

        // Schritt 2: Gemeinsame Regeln identifizieren
        await this.identifyCommonRules();

        // Schritt 3: Atomic CSS-Module erstellen
        await this.createAtomicModules();

        // Schritt 4: Komponenten refactoren
        await this.refactorComponents(components);

        console.log('âœ… CSS-Extraktion abgeschlossen!');
        this.printStatistics();
    }

    async extractComponentCSS(componentName) {
        const filePath = path.join(this.componentsDir, componentName, 'index.html');
        const content = fs.readFileSync(filePath, 'utf8');

        // CSS zwischen <style> und </style> extrahieren
        const styleMatch = content.match(/<style>([\s\S]*?)<\/style>/);
        if (!styleMatch) {
            console.log(`âš ï¸  Keine Inline-Styles in ${componentName}`);
            return;
        }

        const css = styleMatch[1];
        const rules = this.parseCSS(css);

        console.log(`ğŸ“Š ${componentName}: ${rules.length} CSS-Regeln, ${css.split('\n').length} Zeilen`);

        // Regeln kategorisieren
        rules.forEach(rule => {
            const key = rule.selector;
            if (!this.commonRules.has(key)) {
                this.commonRules.set(key, []);
            }
            this.commonRules.get(key).push({
                component: componentName,
                selector: rule.selector,
                properties: rule.properties
            });
        });
    }

    parseCSS(css) {
        const rules = [];
        // Vereinfachter CSS-Parser fÃ¼r Selektoren und Properties
        const ruleMatches = css.match(/([^{}]+)\s*\{([^{}]*)\}/g);
        
        if (ruleMatches) {
            ruleMatches.forEach(ruleMatch => {
                const [, selector, properties] = ruleMatch.match(/([^{}]+)\s*\{([^{}]*)\}/);
                if (selector && properties) {
                    rules.push({
                        selector: selector.trim(),
                        properties: properties.trim()
                    });
                }
            });
        }

        return rules;
    }

    async identifyCommonRules() {
        console.log('ğŸ” Identifiziere gemeinsame CSS-Regeln...');

        const commonSelectors = new Map();
        const threshold = 3; // Mindestens 3 Komponenten mÃ¼ssen den Selektor verwenden

        this.commonRules.forEach((rules, selector) => {
            if (rules.length >= threshold) {
                commonSelectors.set(selector, rules);
                console.log(`ğŸ¯ Gemeinsamer Selektor: ${selector} (${rules.length} Komponenten)`);
            }
        });

        this.commonSelectors = commonSelectors;
    }

    async createAtomicModules() {
        console.log('ğŸ—ï¸  Erstelle Atomic CSS-Module...');

        // Module-Kategorien
        const modules = {
            'atomic-sections.css': ['.section', '.section-title', '.section-subtitle', '.implementation-section'],
            'atomic-accessibility.css': ['.accessibility-grid', '.accessibility-item'],
            'atomic-navigation.css': ['.sidebar', '.nav-item', '.nav-section'],
            'atomic-buttons.css': ['.lyd-button', '.copy-button'],
            'atomic-layout.css': ['.container', '.main-content', '.header']
        };

        for (const [moduleFile, selectors] of Object.entries(modules)) {
            let moduleCSS = `/* ${moduleFile} - Atomic CSS Module */\n/* Auto-generated by css-extractor.js */\n\n`;

            selectors.forEach(selector => {
                if (this.commonSelectors.has(selector)) {
                    const rules = this.commonSelectors.get(selector);
                    // Nimm die hÃ¤ufigste Variante (oder die der Input-Komponente als Gold Standard)
                    const goldStandardRule = rules.find(r => r.component === 'inputs') || rules[0];
                    moduleCSS += `${selector} {\n${goldStandardRule.properties}\n}\n\n`;
                }
            });

            const modulePath = path.join(this.sharedDir, moduleFile);
            fs.writeFileSync(modulePath, moduleCSS);
            console.log(`âœ… Erstellt: ${moduleFile}`);
        }
    }

    async refactorComponents(components) {
        console.log('ğŸ”§ Refactore Komponenten fÃ¼r Atomic CSS...');

        for (const component of components) {
            await this.refactorComponent(component);
        }
    }

    async refactorComponent(componentName) {
        const filePath = path.join(this.componentsDir, componentName, 'index.html');
        let content = fs.readFileSync(filePath, 'utf8');

        // Backup erstellen
        const backupPath = `${filePath}.backup-${Date.now()}`;
        fs.writeFileSync(backupPath, content);

        // Atomic CSS-Imports hinzufÃ¼gen
        const atomicImports = `
    <!-- Atomic CSS Modules -->
    <link rel="stylesheet" href="../shared/atomic-sections.css">
    <link rel="stylesheet" href="../shared/atomic-accessibility.css">
    <link rel="stylesheet" href="../shared/atomic-navigation.css">
    <link rel="stylesheet" href="../shared/atomic-buttons.css">
    <link rel="stylesheet" href="../shared/atomic-layout.css">`;

        // Nach den bestehenden shared CSS-Imports einfÃ¼gen
        content = content.replace(
            /(<link rel="stylesheet" href="\.\.\/shared\/components\.css">)/,
            `$1${atomicImports}`
        );

        // Inline-CSS reduzieren (nur komponenten-spezifische Styles behalten)
        const styleMatch = content.match(/<style>([\s\S]*?)<\/style>/);
        if (styleMatch) {
            const originalCSS = styleMatch[1];
            const reducedCSS = this.reduceInlineCSS(originalCSS, componentName);
            content = content.replace(styleMatch[0], `<style>${reducedCSS}</style>`);

            const originalLines = originalCSS.split('\n').length;
            const reducedLines = reducedCSS.split('\n').length;
            console.log(`ğŸ“‰ ${componentName}: ${originalLines} â†’ ${reducedLines} Zeilen CSS (${Math.round((1 - reducedLines/originalLines) * 100)}% Reduktion)`);
        }

        fs.writeFileSync(filePath, content);
        console.log(`âœ… Refactored: ${componentName}`);
    }

    reduceInlineCSS(css, componentName) {
        // Entferne alle Regeln, die jetzt in Atomic Modules sind
        const atomicSelectors = [
            '.section', '.section-title', '.section-subtitle', '.implementation-section',
            '.accessibility-grid', '.accessibility-item',
            '.sidebar', '.nav-item', '.nav-section',
            '.lyd-button', '.copy-button',
            '.container', '.main-content', '.header'
        ];

        let reducedCSS = `        /* ${componentName.toUpperCase()} - Komponenten-spezifische Styles */\n        /* Gemeinsame Styles sind jetzt in atomic-*.css Modulen */\n\n`;

        // Behalte nur komponenten-spezifische Selektoren
        const rules = this.parseCSS(css);
        rules.forEach(rule => {
            const isAtomic = atomicSelectors.some(atomic => 
                rule.selector.includes(atomic) || rule.selector === atomic
            );

            if (!isAtomic) {
                // Komponenten-spezifische Regel behalten
                reducedCSS += `        ${rule.selector} {\n        ${rule.properties}\n        }\n\n`;
            }
        });

        return reducedCSS;
    }

    printStatistics() {
        console.log('\nğŸ“Š EXTRAKTION STATISTIKEN:');
        console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
        console.log(`ğŸ¯ Gemeinsame Selektoren: ${this.commonSelectors?.size || 0}`);
        console.log(`ğŸ“ Atomic Module erstellt: 5`);
        console.log(`ğŸ”§ Komponenten refactored: ${fs.readdirSync(this.componentsDir).length}`);
        console.log('\nğŸ’¡ NÃ¤chste Schritte:');
        console.log('1. Teste alle Komponenten auf Pixel-Perfect-Gleichheit');
        console.log('2. Deploy und Live-Verifikation');
        console.log('3. Erstelle neues Atomic Template');
    }
}

// CLI AusfÃ¼hrung
if (require.main === module) {
    const extractor = new CSSExtractor();
    extractor.extractAllCSS().catch(console.error);
}

module.exports = CSSExtractor;
